#! /usr/bin/env node

/**
 * This file automatically generates the icon components from the SVG files in
 * the 'front-end/public/icons' folder.
 */

import {
  statSync,
  readdirSync,
  readFileSync,
  writeFileSync,
  existsSync,
  mkdirSync,
  rmSync
} from 'fs';
import { join, resolve, basename, dirname } from 'path';
import camelCase from 'camelcase';
import prettier from 'prettier';
import chokidar from 'chokidar';

// Replaces old CJS __dirname with variable mapped to project root
const __dirname = dirname(resolve('./package.json'));

export const srcPath = resolve(__dirname, 'public/icons');

const componentRootPath = resolve(__dirname, 'components/flourishes/icon');
const componentLibPath = resolve(__dirname, componentRootPath, 'components');

const IconComponentTemplate = `import React, { SVGAttributes } from 'react';

export type Props = SVGAttributes<SVGElement>;

export const {*DISPLAY_NAME*}: React.FC<Props> = ({
  fill = 'currentColor',
  ...props
}: Props) => (
  {*SVG_CONTENT*}
);

{*DISPLAY_NAME*}.displayName = '{*DISPLAY_NAME*}';

export default {*DISPLAY_NAME*};
`;

const rootReadMe = `
# THIS FOLDER IS AUTO-GENERATED

## DO NOT EDIT/DELETE OR ADD ANY FILES IN THIS FOLDER

All files in this folder are automatically generated by by the
'scripts/generate-icons.mjs' script.

If you want to add a new icon, add an SVG file with the icon name (in kebab-case)
to the 'public/icons' folder and run 'yarn generate:icons' to generate the new
icon component.

If you want to delete an icon, delete the SVG file from the 'public/icons' folder
and run 'yarn generate:icons' to delete the icon component.

If you want to edit an icon, edit the SVG file in the 'public/icons' folder and
run 'yarn generate:icons' to regenerate the icon component.
`;

// Take the contents of the SVG file and insert it into the template
const convertIcon = (file) => {
  const name = basename(file, '.svg');

  const contents = readFileSync(file, 'utf8');
  let newContents = contents;
  // Strip out the XML declaration
  const xmlDeclaration = contents.match(/<\?xml[^>]+>/);
  if (xmlDeclaration) {
    newContents = newContents.replace(xmlDeclaration[0], '');
  }
  // Strip out any comments
  newContents = newContents.replace(/<!--[^>]+-->/g, '');
  // Strip out the DOCTYPE
  const doctype = contents.match(/<!DOCTYPE[^>]+>/);
  if (doctype) {
    newContents = newContents.replace(doctype[0], '');
  }
  // Find the opening tag of the SVG element and add the required attributes
  const svgStart = newContents.indexOf('<svg');
  const svgEnd = newContents.indexOf('>', svgStart);
  const svgAttributes = newContents.slice(svgStart + 4, svgEnd);
  // Remove any existing fill attributes
  let newSvgAttributes = svgAttributes.replace(/fill="[^"]+"/, '');
  // Remove any existing class attributes
  newSvgAttributes = newSvgAttributes.replace(/class="[^"]+"/, '');
  // Remove any existing style attributes
  newSvgAttributes = newSvgAttributes.replace(/style="[^"]+"/, '');
  // Convert xmlns:xlink to valid JSX
  newSvgAttributes = newSvgAttributes.replace('xmlns:xlink', 'xmlnsXlink');
  // Convert xlink:href to valid JSX
  newSvgAttributes = newSvgAttributes.replace('xlink:href', 'xlinkHref');
  // Convert xml:space to valid JSX
  newSvgAttributes = newSvgAttributes.replace('xml:space', 'xmlSpace');
  // Add the fill attribute and spread the props
  newSvgAttributes = newSvgAttributes.concat('\nfill={fill}\n{...props}');
  newContents = newContents.replace(svgAttributes, newSvgAttributes);

  // Find all attributes within the file and make sure they are
  // camelCased (for JSX compliance)
  newContents = newContents.replace(/\s[a-z-]+=/g, (match) => {
    const attribute = match.trim();
    const camelCasedAttribute = camelCase(attribute);
    return ` ${camelCasedAttribute}`;
  });

  let output = IconComponentTemplate.replace('{*SVG_CONTENT*}', newContents)
    .replace(/{\*DISPLAY_NAME\*}/g, camelCase(name, { pascalCase: true }))
    .replace('</svg>;', '</svg>');
  // Tidy up the output and write it to the output directory
  const cleanOutput = prettier.format(output, {
    parser: 'flow',
    singleQuote: true
  });
  writeFileSync(join(componentLibPath, `${name}.tsx`), cleanOutput);
};

// Read all the files in the 'srcPath' directory and if they are SVG files, process them
const processFiles = (file) => {
  const stat = statSync(file);
  if (stat.isDirectory()) {
    throw new Error(
      'Subdirectories are not supported, please add your SVG files to the root of the icons folder'
    );
  } else if (stat.isFile() && file.endsWith('.svg')) {
    convertIcon(file);
  }
};

const generateIndex = (files) => {
  // First generate all of the default exports
  const index = files
    .map((file) => {
      const name = basename(file, '.svg');
      return `import ${camelCase(name, {
        pascalCase: true
      })} from './${name}';`;
    })
    .join('\n');

  // Then generate the icon object
  let iconObjectTemplate = `const icons = {`;

  files.forEach((file) => {
    const name = camelCase(basename(file, '.svg'), { pascalCase: true });
    iconObjectTemplate += `
      ${name.toLowerCase()}: ${name},`;
  });

  iconObjectTemplate += `}`;

  const fileContents = `${index}\n\n${iconObjectTemplate}\n\nexport default icons;`;
  const cleanOutput = prettier.format(fileContents, {
    parser: 'typescript',
    singleQuote: true,
    trailingComma: 'none'
  });

  writeFileSync(join(componentLibPath, 'index.tsx'), cleanOutput);
};

// Generate the icon gallery for storybook

const generateGallery = (files) => {
  let galleryTemplate = `/**THIS FILE IS AUTOGENERATED, DO NOT EDIT**/\nimport { IconGallery, IconItem } from '@storybook/blocks';
  import { Icon } from './index';
  const Gallery = () => (
    <IconGallery>
  `;
  files.forEach((file) => {
    const name = camelCase(basename(file, '.svg'), { pascalCase: true });
    galleryTemplate += `
      <IconItem name="${name}">
        <Icon use="${name.toLowerCase()}" />
      </IconItem>
    `;
  });
  galleryTemplate += `</IconGallery>);\nexport default Gallery;`;
  const cleanOutput = prettier.format(galleryTemplate, {
    parser: 'typescript',
    singleQuote: true,
    trailingComma: 'none'
  });
  writeFileSync(join(componentRootPath, 'gallery.tsx'), cleanOutput);
};

const runGenerator = () => {
  const files = readdirSync(srcPath).filter((file) => file.endsWith('.svg'));
  if (existsSync(componentLibPath)) {
    // If the output directory already exists, delete it and recreate it
    // that any deleted icons are also deleted from the component library and that we have a clean slate
    rmSync(componentLibPath, { recursive: true, force: true });
  }
  mkdirSync(componentLibPath);
  // Add a README.md file to the output directory to explain what it is and to warn
  // developers not to edit or add to the files in this directory
  writeFileSync(join(componentLibPath, 'README.md'), rootReadMe);
  // Create an index.ts file that exports all the icons
  generateIndex(files);
  // Create a gallery.tsx file that exports all the icons for storybook
  generateGallery(files);
  files.forEach((file) => {
    const filePath = join(srcPath, file);
    processFiles(filePath);
  });
};

(function () {
  // Run the generator once to start with
  runGenerator();
  // If the script is called with '--watch' or '-w'. Watch for changes to the docs folder and re-run the script
  if (process.argv.includes('--watch') || process.argv.includes('-w')) {
    chokidar
      .watch(resolve(srcPath), {
        ignored: /(^|[\/\\])\../,
        ignoreInitial: true
      })
      .on('ready', () => {
        console.log('Watching ./public/icons folder for changes...');
      })
      .on('all', (event, path) => {
        console.log(event, path);
        runGenerator();
      });
  }
})();
