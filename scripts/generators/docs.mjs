#! /usr/bin/env node

/**
 * This file automatically generates the MDX docs for storybook from any
 * markdown files in the '/docs' directory or any file added to the
 * 'includes' array.
 */

import {
  statSync,
  readdirSync,
  readFileSync,
  writeFileSync,
  existsSync,
  cpSync,
  mkdirSync,
  rmSync
} from 'fs';
import chokidar from 'chokidar';
import { join, resolve, basename, dirname, parse } from 'path';
import camelCase from 'camelcase';
import config from '../../package.json' assert { type: 'json' };

// Replaces old CJS __dirname with variable mapped to project root
const __dirname = dirname(resolve('./package.json'));
const versionNumber = config.builda.prefab.version;

// Includes and excludes should be relative to the root of the project
export const includes = ['docs'];
const excludes = ['.DS_Store'];

const sbRoot = resolve(__dirname, '.storybook');
const output = resolve(`${sbRoot}/.docs`);

// If the output directory doesn't exist, create it
if (!existsSync(output)) {
  mkdirSync(output);
}

const rootReadMe = `
# What's this?

This folder is where the MDX versions of the files in the docs folder are stored.
It is automatically generated by by the 'scripts/generate-docs.mjs' script and can safely
be ignored.
`;

const formatName = (fileName) => {
  let prefix = '';
  let outputName = fileName;
  if (outputName.startsWith('adr-')) {
    const matcher = outputName.match(/adr-([0-9]{3})-([a-z-]+)+/);
    if (matcher) {
      [, prefix, outputName] = matcher;
      prefix = prefix.toUpperCase() + ': ';
    }
  }

  outputName = camelCase(outputName, { pascalCase: true })
    .replace(/([A-Z][a-z])/g, ' $1')
    .replace(/(\d)/g, ' $1')
    .trim();
  return `${prefix}${outputName}`;
};
// read all files in the includes array and if they are markdown files, process them
// if it s a directory, recursively read all files in the directory and start again
const recurseDirectories = (file) => {
  if (excludes.includes(basename(file))) {
    return;
  }

  if (statSync(file).isDirectory()) {
    const dirs = readdirSync(file);
    return dirs.forEach((dir) => {
      // Check if the directory is the images directory, copy it to the project and
      // return
      if (dir === 'images') {
        cpSync(join(file, dir), resolve(__dirname, output, 'images'), {
          recursive: true
        });
        return;
      }
      recurseDirectories(join(file, dir));
    });
  }

  // Get the file path from the root of the repo
  const filePath = resolve(__dirname, file);
  const baseFileName = parse(filePath).name;
  console.log('Processing file: ', filePath);
  let dirName = parse(filePath)
    .dir.replace(__dirname, '')
    .replace(`/docs/`, '')
    .trim();

  dirName = formatName(dirName);
  let directory = dirName.replace('/', '').replace(' ', '-').toLowerCase();
  if (directory === 'docs') {
    directory = '';
  }

  if (!existsSync(resolve(__dirname, output, directory))) {
    mkdirSync(resolve(__dirname, output, directory));
  }

  const fileContents = readFileSync(filePath, 'utf8');

  let pageTitle = baseFileName;
  pageTitle = formatName(pageTitle);

  pageTitle === 'Readme' && (pageTitle = 'Introduction');
  pageTitle === 'Index' && (pageTitle = 'Introduction');
  const pagePath = `${directory ? formatName(directory) + '/' : ''}`;
  let convertedContent = `{/* This file is automatically generated by the 'scripts/generate-docs.mjs' script. Do not edit it directly. */}\n\n<Meta title="${pagePath}${pageTitle}" />\n\n`;
  fileContents.split('\n').forEach((line) => {
    // If we are on the intro page, append the version number to the header
    if (pageTitle === 'Introduction' && line.startsWith('# Jackanory')) {
      convertedContent += `# Jackanory v${versionNumber}\n\n<Version /> \n\n`;
      return;
    }

    // If there are multiple blank lines, remove them
    if (line === '' && convertedContent.endsWith('\n\n')) {
      return;
    }

    // If the line is an import move it to the top of the file
    if (line.startsWith('#import')) {
      convertedContent = line.replace('#', '') + '\n\n' + convertedContent;
      return;
    }

    const regex = /\[([\Ss ]+)\]\((.\/[a-z-/]+.md)\)/;
    if (regex.test(line)) {
      const [, , link] = line.match(regex);
      let convertedLink = link
        .replace(/\.\/(docs)?\/*/, '@temp@')
        .replace(/\//g, '-')
        .replace('.md', '--docs#top');
      if (!directory) {
        convertedLink = convertedLink.replace('@temp@', '?path=/story/docs-');
      } else {
        convertedLink = convertedLink.replace(
          '@temp@',
          `?path=/story/docs-${directory}-`
        );
      }

      const newLine = line.replace(link, convertedLink);

      convertedContent += newLine + '\n';
    } else {
      convertedContent += line + '\n';
    }
  });

  let fileName = '';
  if (baseFileName === 'README.md') {
    fileName = 'introduction.mdx';
  } else {
    fileName = baseFileName.replace('_', '-').toLowerCase() + '.mdx';
  }
  // Output the file to the output folder
  writeFileSync(resolve(output, directory, fileName), convertedContent, 'utf8');
};

const updateStorybookLogo = () => {
  const logo = readFileSync(
    resolve(__dirname, `${sbRoot}/jackanory-storybook-logo.svg`),
    'utf8'
  );
  const newLogo = logo.replace(/v\d+\.\d+\.\d+/, `v${versionNumber}`);
  writeFileSync(
    resolve(__dirname, `${output}/images/jackanory-storybook-logo.svg`),
    newLogo,
    'utf8'
  );
};

const runGenerator = () => {
  // Check the output dir exists and create it if not
  if (existsSync(output)) {
    // If the output dir exists, delete all files in it so we can start fresh
    rmSync(output, { force: true, recursive: true });
  }
  mkdirSync(output);
  // Create the root README file
  writeFileSync(resolve(__dirname, output, 'README.md'), rootReadMe, 'utf8');

  // Process the includes array
  includes.map((d) => recurseDirectories(resolve(__dirname, d)));

  // Update the storybook logo
  updateStorybookLogo();
};

(function () {
  // Run the generator once to start with
  runGenerator();
  // If the script is called with '--watch' or '-w'. Watch for changes to the target folder and re-run the script
  if (process.argv.includes('--watch') || process.argv.includes('-w')) {
    chokidar
      .watch(
        includes.map((i) => resolve(i)),
        {
          ignored: /(^|[\/\\])\../,
          ignoreInitial: true
        }
      )
      .on('ready', () => {
        console.log('Watching docs folder(s) for changes...');
      })
      .on('all', (event, path) => {
        console.log(event, path);
        runGenerator();
      });
  }
})();
